## API Report File for "@beraborrow/lib-base"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @internal (undocumented)
export interface _BeraBorrowReadCache<T extends unknown[]> extends _BeraBorrowReadCacheBase<T> {
    // (undocumented)
    getTroves(params: TroveListingParams & {
        beforeRedistribution: true;
    }, ...extraParams: T): TroveWithPendingRedistribution[] | undefined;
    // (undocumented)
    getTroves(params: TroveListingParams, ...extraParams: T): UserTrove[] | undefined;
}

// @internal (undocumented)
export type _BeraBorrowReadCacheBase<T extends unknown[]> = {
    [P in keyof ReadableBeraBorrow]: ReadableBeraBorrow[P] extends (...args: infer A) => Promise<infer R> ? (...params: [...originalParams: A, ...extraParams: T]) => R | undefined : never;
};

// @public
export type BeraBorrowReceipt<R = unknown, D = unknown> = PendingReceipt | MinedReceipt<R, D>;

// @public
export abstract class BeraBorrowStore<T = unknown> {
    // @internal (undocumented)
    protected abstract _doStart(): () => void;
    // @internal (undocumented)
    protected _load(baseState: BeraBorrowStoreBaseState, extraState?: T): void;
    // @internal (undocumented)
    protected _loaded: boolean;
    logging: boolean;
    onLoaded?: () => void;
    // @internal (undocumented)
    protected abstract _reduceExtra(extraState: T, extraStateUpdate: Partial<T>): T;
    start(): () => void;
    get state(): BeraBorrowStoreState<T>;
    subscribe(listener: (params: BeraBorrowStoreListenerParams<T>) => void): () => void;
    // @internal (undocumented)
    protected _update(baseStateUpdate?: Partial<BeraBorrowStoreBaseState>, extraStateUpdate?: Partial<T>): void;
    }

// @public
export interface BeraBorrowStoreBaseState {
    accountBalance: Decimal;
    collateralSurplusBalance: Decimal;
    // @internal (undocumented)
    _feesInNormalMode: Fees;
    frontend: FrontendStatus;
    liquidityMiningPOLLENReward: Decimal;
    liquidityMiningStake: Decimal;
    nectBalance: Decimal;
    nectInStabilityPool: Decimal;
    numberOfTroves: number;
    ownFrontend: FrontendStatus;
    pollenBalance: Decimal;
    pollenStake: POLLENStake;
    price: Decimal;
    remainingLiquidityMiningPOLLENReward: Decimal;
    remainingStabilityPoolPOLLENReward: Decimal;
    // @internal (undocumented)
    _riskiestTroveBeforeRedistribution: TroveWithPendingRedistribution;
    stabilityDeposit: StabilityDeposit;
    total: Trove;
    totalRedistributed: Trove;
    totalStakedPOLLEN: Decimal;
    totalStakedUniTokens: Decimal;
    troveBeforeRedistribution: TroveWithPendingRedistribution;
    uniTokenAllowance: Decimal;
    uniTokenBalance: Decimal;
}

// @public
export interface BeraBorrowStoreDerivedState {
    borrowingRate: Decimal;
    fees: Fees;
    haveUndercollateralizedTroves: boolean;
    redemptionRate: Decimal;
    trove: UserTrove;
}

// @public
export interface BeraBorrowStoreListenerParams<T = unknown> {
    newState: BeraBorrowStoreState<T>;
    oldState: BeraBorrowStoreState<T>;
    stateChange: Partial<BeraBorrowStoreState<T>>;
}

// @public
export type BeraBorrowStoreState<T = unknown> = BeraBorrowStoreBaseState & BeraBorrowStoreDerivedState & T;

// @internal (undocumented)
export class _CachedReadableBeraBorrow<T extends unknown[]> implements _ReadableBeraBorrowWithExtraParams<T> {
    constructor(readable: _ReadableBeraBorrowWithExtraParams<T>, cache: _BeraBorrowReadCache<T>);
    // (undocumented)
    getCollateralSurplusBalance(address?: string, ...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getFees(...extraParams: T): Promise<Fees>;
    // (undocumented)
    getFrontendStatus(address?: string, ...extraParams: T): Promise<FrontendStatus>;
    // (undocumented)
    getLiquidityMiningPOLLENReward(address?: string, ...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getLiquidityMiningStake(address?: string, ...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getNECTBalance(address?: string, ...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getNECTInStabilityPool(...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getNumberOfTroves(...extraParams: T): Promise<number>;
    // (undocumented)
    getPOLLENBalance(address?: string, ...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getPOLLENStake(address?: string, ...extraParams: T): Promise<POLLENStake>;
    // (undocumented)
    getPrice(...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getRemainingLiquidityMiningPOLLENReward(...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getRemainingStabilityPoolPOLLENReward(...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getStabilityDeposit(address?: string, ...extraParams: T): Promise<StabilityDeposit>;
    // (undocumented)
    getTotal(...extraParams: T): Promise<Trove>;
    // (undocumented)
    getTotalRedistributed(...extraParams: T): Promise<Trove>;
    // (undocumented)
    getTotalStakedPOLLEN(...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getTotalStakedUniTokens(...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getTrove(address?: string, ...extraParams: T): Promise<UserTrove>;
    // (undocumented)
    getTroveBeforeRedistribution(address?: string, ...extraParams: T): Promise<TroveWithPendingRedistribution>;
    // (undocumented)
    getTroves(params: TroveListingParams & {
        beforeRedistribution: true;
    }, ...extraParams: T): Promise<TroveWithPendingRedistribution[]>;
    // (undocumented)
    getTroves(params: TroveListingParams, ...extraParams: T): Promise<UserTrove[]>;
    // (undocumented)
    getUniTokenAllowance(address?: string, ...extraParams: T): Promise<Decimal>;
    // (undocumented)
    getUniTokenBalance(address?: string, ...extraParams: T): Promise<Decimal>;
    }

// @internal (undocumented)
export type _CollateralChange<T> = (_CollateralDeposit<T> & _NoCollateralWithdrawal) | (_CollateralWithdrawal<T> & _NoCollateralDeposit);

// @internal (undocumented)
export type _CollateralDeposit<T> = {
    depositCollateral: T;
};

// @public
export interface CollateralGainTransferDetails extends StabilityPoolGainsWithdrawalDetails {
    newTrove: Trove;
}

// @internal (undocumented)
export type _CollateralWithdrawal<T> = {
    withdrawCollateral: T;
};

// @public
export const CRITICAL_COLLATERAL_RATIO: Decimal;

// @internal (undocumented)
export type _DebtChange<T> = (_NECTBorrowing<T> & _NoNECTRepayment) | (_NECTRepayment<T> & _NoNECTBorrowing);

// @public
export class Decimal {
    // @internal (undocumented)
    get absoluteValue(): this;
    // (undocumented)
    add(addend: Decimalish): Decimal;
    // @internal (undocumented)
    get bigNumber(): string;
    // (undocumented)
    div(divider: Decimalish): Decimal;
    // @internal (undocumented)
    _divCeil(divider: Decimalish): Decimal;
    // (undocumented)
    eq(that: Decimalish): boolean;
    // (undocumented)
    get finite(): this | undefined;
    // (undocumented)
    static from(decimalish: Decimalish): Decimal;
    // (undocumented)
    static fromBigNumberString(bigNumberString: string): Decimal;
    // (undocumented)
    gt(that: Decimalish): boolean;
    // (undocumented)
    gte(that: Decimalish): boolean;
    // (undocumented)
    static readonly HALF: Decimal;
    // @internal (undocumented)
    get hex(): string;
    // (undocumented)
    get infinite(): this | undefined;
    // (undocumented)
    static readonly INFINITY: Decimal;
    // (undocumented)
    get isZero(): boolean;
    // (undocumented)
    lt(that: Decimalish): boolean;
    // (undocumented)
    lte(that: Decimalish): boolean;
    // (undocumented)
    static max(a: Decimalish, b: Decimalish): Decimal;
    // (undocumented)
    static min(a: Decimalish, b: Decimalish): Decimal;
    // (undocumented)
    mul(multiplier: Decimalish): Decimal;
    // (undocumented)
    mulDiv(multiplier: Decimalish, divider: Decimalish): Decimal;
    // (undocumented)
    get nonZero(): this | undefined;
    // (undocumented)
    static readonly ONE: Decimal;
    // (undocumented)
    pow(exponent: number): Decimal;
    // (undocumented)
    prettify(precision?: number): string;
    // (undocumented)
    shorten(): string;
    // (undocumented)
    sub(subtrahend: Decimalish): Decimal;
    // (undocumented)
    toString(precision?: number): string;
    // (undocumented)
    static readonly ZERO: Decimal;
    // (undocumented)
    get zero(): this | undefined;
}

// @public
export type Decimalish = Decimal | number | string;

// @alpha (undocumented)
export class Difference {
    // (undocumented)
    get absoluteValue(): Decimal | undefined;
    // (undocumented)
    static between(d1: Decimalish | undefined, d2: Decimalish | undefined): Difference;
    // (undocumented)
    get finite(): this | undefined;
    // (undocumented)
    get infinite(): this | undefined;
    // (undocumented)
    mul(multiplier: Decimalish): Difference;
    // (undocumented)
    get negative(): this | undefined;
    // (undocumented)
    get nonZero(): this | undefined;
    // (undocumented)
    get positive(): this | undefined;
    // (undocumented)
    prettify(precision?: number): string;
    // (undocumented)
    toString(precision?: number): string;
}

// @internal (undocumented)
export const _emptyTrove: Trove;

// @public
export type FailedReceipt<R = unknown> = {
    status: "failed";
    rawReceipt: R;
};

// @internal (undocumented)
export const _failedReceipt: <R>(rawReceipt: R) => FailedReceipt<R>;

// @public
export class Fees {
    // @internal
    constructor(baseRateWithoutDecay: Decimalish, minuteDecayFactor: Decimalish, beta: Decimalish, lastFeeOperation: Date, timeOfLatestBlock: Date, recoveryMode: boolean);
    // @internal (undocumented)
    baseRate(when?: Date): Decimal;
    borrowingRate(when?: Date): Decimal;
    equals(that: Fees): boolean;
    redemptionRate(redeemedFractionOfSupply?: Decimalish, when?: Date): Decimal;
    // @internal (undocumented)
    _setRecoveryMode(recoveryMode: boolean): Fees;
    // @internal (undocumented)
    toString(): string;
}

// @public
export type FrontendStatus = {
    status: "unregistered";
} | {
    status: "registered";
    kickbackRate: Decimal;
};

// @public
export interface LiquidationDetails {
    collateralGasCompensation: Decimal;
    liquidatedAddresses: string[];
    nectGasCompensation: Decimal;
    totalLiquidated: Trove;
}

// @public
export const MAXIMUM_BORROWING_RATE: Decimal;

// @public
export type MinedReceipt<R = unknown, D = unknown> = FailedReceipt<R> | SuccessfulReceipt<R, D>;

// @public
export const MINIMUM_BORROWING_RATE: Decimal;

// @public
export const MINIMUM_COLLATERAL_RATIO: Decimal;

// @public
export const MINIMUM_REDEMPTION_RATE: Decimal;

// @public
export const NECT_LIQUIDATION_RESERVE: Decimal;

// @public
export const NECT_MINIMUM_DEBT: Decimal;

// @public
export const NECT_MINIMUM_NET_DEBT: Decimal;

// @internal (undocumented)
export type _NECTBorrowing<T> = {
    borrowNECT: T;
};

// @internal (undocumented)
export type _NECTRepayment<T> = {
    repayNECT: T;
};

// @internal (undocumented)
export type _NoCollateralChange = _NoCollateralDeposit & _NoCollateralWithdrawal;

// @internal (undocumented)
export type _NoCollateralDeposit = Partial<_CollateralDeposit<undefined>>;

// @internal (undocumented)
export type _NoCollateralWithdrawal = Partial<_CollateralWithdrawal<undefined>>;

// @internal (undocumented)
export type _NoDebtChange = _NoNECTBorrowing & _NoNECTRepayment;

// @internal (undocumented)
export type _NoNECTBorrowing = Partial<_NECTBorrowing<undefined>>;

// @internal (undocumented)
export type _NoNECTRepayment = Partial<_NECTRepayment<undefined>>;

// @internal (undocumented)
export const _normalizeTroveAdjustment: (params: Record<string, Decimalish | undefined>) => TroveAdjustmentParams<Decimal>;

// @internal (undocumented)
export const _normalizeTroveCreation: (params: Record<string, Decimalish | undefined>) => TroveCreationParams<Decimal>;

// @alpha (undocumented)
export interface ObservableBeraBorrow {
    // (undocumented)
    watchNECTBalance(onNECTBalanceChanged: (balance: Decimal) => void, address?: string): () => void;
    // (undocumented)
    watchNECTInStabilityPool(onNECTInStabilityPoolChanged: (nectInStabilityPool: Decimal) => void): () => void;
    // (undocumented)
    watchNumberOfTroves(onNumberOfTrovesChanged: (numberOfTroves: number) => void): () => void;
    // (undocumented)
    watchPrice(onPriceChanged: (price: Decimal) => void): () => void;
    // (undocumented)
    watchStabilityDeposit(onStabilityDepositChanged: (stabilityDeposit: StabilityDeposit) => void, address?: string): () => void;
    // (undocumented)
    watchTotal(onTotalChanged: (total: Trove) => void): () => void;
    // (undocumented)
    watchTotalRedistributed(onTotalRedistributedChanged: (totalRedistributed: Trove) => void): () => void;
    // (undocumented)
    watchTroveWithoutRewards(onTroveChanged: (trove: TroveWithPendingRedistribution) => void, address?: string): () => void;
}

// @public
export type PendingReceipt = {
    status: "pending";
};

// @internal (undocumented)
export const _pendingReceipt: PendingReceipt;

// @alpha (undocumented)
export class Percent<T extends {
    infinite?: T | undefined;
    absoluteValue?: A | undefined;
    mul?(hundred: 100): T;
    toString(precision?: number): string;
}, A extends {
    gte(n: string): boolean;
}> {
    constructor(ratio: T);
    // (undocumented)
    nonZeroish(precision: number): this | undefined;
    // (undocumented)
    prettify(): string;
    // (undocumented)
    toString(precision: number): string;
}

// @public
export class POLLENStake {
    // @internal
    constructor(stakedPOLLEN?: Decimal, collateralGain?: Decimal, nectGain?: Decimal);
    apply(change: POLLENStakeChange<Decimalish> | undefined): Decimal;
    readonly collateralGain: Decimal;
    equals(that: POLLENStake): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    readonly nectGain: Decimal;
    readonly stakedPOLLEN: Decimal;
    // @internal (undocumented)
    toString(): string;
    whatChanged(thatStakedPOLLEN: Decimalish): POLLENStakeChange<Decimal> | undefined;
}

// @public
export type POLLENStakeChange<T> = {
    stakePOLLEN: T;
    unstakePOLLEN?: undefined;
} | {
    stakePOLLEN?: undefined;
    unstakePOLLEN: T;
    unstakeAllPOLLEN: boolean;
};

// Warning: (ae-incompatible-release-tags) The symbol "PopulatableBeraBorrow" is marked as @public, but its signature references "_PopulatableFrom" which is marked as @internal
//
// @public
export interface PopulatableBeraBorrow<R = unknown, S = unknown, P = unknown> extends _PopulatableFrom<SendableBeraBorrow<R, S>, P> {
    adjustTrove(params: TroveAdjustmentParams<Decimalish>, maxBorrowingRate?: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>>;
    approveUniTokens(allowance?: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    borrowNECT(amount: Decimalish, maxBorrowingRate?: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>>;
    claimCollateralSurplus(): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    closeTrove(): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveClosureDetails>>>>;
    depositCollateral(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>>;
    depositNECTInStabilityPool(amount: Decimalish, frontendTag?: string): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, StabilityDepositChangeDetails>>>>;
    exitLiquidityMining(): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    liquidate(address: string | string[]): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, LiquidationDetails>>>>;
    liquidateUpTo(maximumNumberOfTrovesToLiquidate: number): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, LiquidationDetails>>>>;
    openTrove(params: TroveCreationParams<Decimalish>, maxBorrowingRate?: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveCreationDetails>>>>;
    redeemNECT(amount: Decimalish, maxRedemptionRate?: Decimalish): Promise<PopulatedRedemption<P, S, R>>;
    registerFrontend(kickbackRate: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    repayNECT(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>>;
    sendNECT(toAddress: string, amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    sendPOLLEN(toAddress: string, amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    // @internal (undocumented)
    setPrice(price: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    stakePOLLEN(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    stakeUniTokens(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    transferCollateralGainToTrove(): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, CollateralGainTransferDetails>>>>;
    unstakePOLLEN(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    unstakeUniTokens(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    withdrawCollateral(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>>;
    withdrawGainsFromStabilityPool(): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, StabilityPoolGainsWithdrawalDetails>>>>;
    withdrawGainsFromStaking(): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
    withdrawNECTFromStabilityPool(amount: Decimalish): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, StabilityDepositChangeDetails>>>>;
    withdrawPOLLENRewardFromLiquidityMining(): Promise<PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>>;
}

// @internal (undocumented)
export type _PopulatableFrom<T, P> = {
    [M in keyof T]: T[M] extends (...args: infer A) => Promise<infer U> ? U extends SentBeraBorrowTransaction ? (...args: A) => Promise<PopulatedBeraBorrowTransaction<P, U>> : never : never;
};

// @public
export interface PopulatedBeraBorrowTransaction<P = unknown, T extends SentBeraBorrowTransaction = SentBeraBorrowTransaction> {
    readonly rawPopulatedTransaction: P;
    send(): Promise<T>;
}

// @public
export interface PopulatedRedemption<P = unknown, S = unknown, R = unknown> extends PopulatedBeraBorrowTransaction<P, SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, RedemptionDetails>>> {
    readonly attemptedNECTAmount: Decimal;
    increaseAmountByMinimumNetDebt(maxRedemptionRate?: Decimalish): Promise<PopulatedRedemption<P, S, R>>;
    readonly isTruncated: boolean;
    readonly redeemableNECTAmount: Decimal;
}

// @public
export interface ReadableBeraBorrow {
    getCollateralSurplusBalance(address?: string): Promise<Decimal>;
    getFees(): Promise<Fees>;
    getFrontendStatus(address?: string): Promise<FrontendStatus>;
    getLiquidityMiningPOLLENReward(address?: string): Promise<Decimal>;
    getLiquidityMiningStake(address?: string): Promise<Decimal>;
    getNECTBalance(address?: string): Promise<Decimal>;
    getNECTInStabilityPool(): Promise<Decimal>;
    getNumberOfTroves(): Promise<number>;
    getPOLLENBalance(address?: string): Promise<Decimal>;
    getPOLLENStake(address?: string): Promise<POLLENStake>;
    getPrice(): Promise<Decimal>;
    getRemainingLiquidityMiningPOLLENReward(): Promise<Decimal>;
    getRemainingStabilityPoolPOLLENReward(): Promise<Decimal>;
    getStabilityDeposit(address?: string): Promise<StabilityDeposit>;
    getTotal(): Promise<Trove>;
    getTotalRedistributed(): Promise<Trove>;
    getTotalStakedPOLLEN(): Promise<Decimal>;
    getTotalStakedUniTokens(): Promise<Decimal>;
    getTrove(address?: string): Promise<UserTrove>;
    getTroveBeforeRedistribution(address?: string): Promise<TroveWithPendingRedistribution>;
    // @internal (undocumented)
    getTroves(params: TroveListingParams & {
        beforeRedistribution: true;
    }): Promise<TroveWithPendingRedistribution[]>;
    getTroves(params: TroveListingParams): Promise<UserTrove[]>;
    getUniTokenAllowance(address?: string): Promise<Decimal>;
    getUniTokenBalance(address?: string): Promise<Decimal>;
}

// @internal (undocumented)
export interface _ReadableBeraBorrowWithExtraParams<T extends unknown[]> extends _ReadableBeraBorrowWithExtraParamsBase<T> {
    // (undocumented)
    getTroves(params: TroveListingParams & {
        beforeRedistribution: true;
    }, ...extraParams: T): Promise<TroveWithPendingRedistribution[]>;
    // (undocumented)
    getTroves(params: TroveListingParams, ...extraParams: T): Promise<UserTrove[]>;
}

// @internal (undocumented)
export type _ReadableBeraBorrowWithExtraParamsBase<T extends unknown[]> = {
    [P in keyof ReadableBeraBorrow]: ReadableBeraBorrow[P] extends (...params: infer A) => infer R ? (...params: [...originalParams: A, ...extraParams: T]) => R : never;
};

// @public
export interface RedemptionDetails {
    actualNECTAmount: Decimal;
    attemptedNECTAmount: Decimal;
    collateralTaken: Decimal;
    fee: Decimal;
}

// Warning: (ae-incompatible-release-tags) The symbol "SendableBeraBorrow" is marked as @public, but its signature references "_SendableFrom" which is marked as @internal
//
// @public
export interface SendableBeraBorrow<R = unknown, S = unknown> extends _SendableFrom<TransactableBeraBorrow, R, S> {
    adjustTrove(params: TroveAdjustmentParams<Decimalish>, maxBorrowingRate?: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>;
    approveUniTokens(allowance?: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    borrowNECT(amount: Decimalish, maxBorrowingRate?: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>;
    claimCollateralSurplus(): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    closeTrove(): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveClosureDetails>>>;
    depositCollateral(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>;
    depositNECTInStabilityPool(amount: Decimalish, frontendTag?: string): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, StabilityDepositChangeDetails>>>;
    exitLiquidityMining(): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    liquidate(address: string | string[]): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, LiquidationDetails>>>;
    liquidateUpTo(maximumNumberOfTrovesToLiquidate: number): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, LiquidationDetails>>>;
    openTrove(params: TroveCreationParams<Decimalish>, maxBorrowingRate?: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveCreationDetails>>>;
    redeemNECT(amount: Decimalish, maxRedemptionRate?: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, RedemptionDetails>>>;
    registerFrontend(kickbackRate: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    repayNECT(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>;
    sendNECT(toAddress: string, amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    sendPOLLEN(toAddress: string, amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    // @internal (undocumented)
    setPrice(price: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    stakePOLLEN(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    stakeUniTokens(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    transferCollateralGainToTrove(): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, CollateralGainTransferDetails>>>;
    unstakePOLLEN(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    unstakeUniTokens(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    withdrawCollateral(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, TroveAdjustmentDetails>>>;
    withdrawGainsFromStabilityPool(): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, StabilityPoolGainsWithdrawalDetails>>>;
    withdrawGainsFromStaking(): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
    withdrawNECTFromStabilityPool(amount: Decimalish): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, StabilityDepositChangeDetails>>>;
    withdrawPOLLENRewardFromLiquidityMining(): Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, void>>>;
}

// @internal (undocumented)
export type _SendableFrom<T, R, S> = {
    [M in keyof T]: T[M] extends (...args: infer A) => Promise<infer D> ? (...args: A) => Promise<SentBeraBorrowTransaction<S, BeraBorrowReceipt<R, D>>> : never;
};

// @public
export interface SentBeraBorrowTransaction<S = unknown, T extends BeraBorrowReceipt = BeraBorrowReceipt> {
    getReceipt(): Promise<T>;
    readonly rawSentTransaction: S;
    waitForReceipt(): Promise<Extract<T, MinedReceipt>>;
}

// @public
export class StabilityDeposit {
    // @internal
    constructor(initialNECT: Decimal, currentNECT: Decimal, collateralGain: Decimal, pollenReward: Decimal, frontendTag: string);
    apply(change: StabilityDepositChange<Decimalish> | undefined): Decimal;
    readonly collateralGain: Decimal;
    readonly currentNECT: Decimal;
    equals(that: StabilityDeposit): boolean;
    readonly frontendTag: string;
    readonly initialNECT: Decimal;
    // (undocumented)
    get isEmpty(): boolean;
    readonly pollenReward: Decimal;
    // @internal (undocumented)
    toString(): string;
    whatChanged(thatNECT: Decimalish): StabilityDepositChange<Decimal> | undefined;
}

// @public
export type StabilityDepositChange<T> = {
    depositNECT: T;
    withdrawNECT?: undefined;
} | {
    depositNECT?: undefined;
    withdrawNECT: T;
    withdrawAllNECT: boolean;
};

// @public
export interface StabilityDepositChangeDetails extends StabilityPoolGainsWithdrawalDetails {
    change: StabilityDepositChange<Decimal>;
}

// @public
export interface StabilityPoolGainsWithdrawalDetails {
    collateralGain: Decimal;
    nectLoss: Decimal;
    newNECTDeposit: Decimal;
    pollenReward: Decimal;
}

// @public
export type SuccessfulReceipt<R = unknown, D = unknown> = {
    status: "succeeded";
    rawReceipt: R;
    details: D;
};

// @internal (undocumented)
export const _successfulReceipt: <R, D>(rawReceipt: R, details: D, toString?: (() => string) | undefined) => SuccessfulReceipt<R, D>;

// @public
export interface TransactableBeraBorrow {
    adjustTrove(params: TroveAdjustmentParams<Decimalish>, maxBorrowingRate?: Decimalish): Promise<TroveAdjustmentDetails>;
    approveUniTokens(allowance?: Decimalish): Promise<void>;
    borrowNECT(amount: Decimalish, maxBorrowingRate?: Decimalish): Promise<TroveAdjustmentDetails>;
    claimCollateralSurplus(): Promise<void>;
    closeTrove(): Promise<TroveClosureDetails>;
    depositCollateral(amount: Decimalish): Promise<TroveAdjustmentDetails>;
    depositNECTInStabilityPool(amount: Decimalish, frontendTag?: string): Promise<StabilityDepositChangeDetails>;
    exitLiquidityMining(): Promise<void>;
    liquidate(address: string | string[]): Promise<LiquidationDetails>;
    liquidateUpTo(maximumNumberOfTrovesToLiquidate: number): Promise<LiquidationDetails>;
    openTrove(params: TroveCreationParams<Decimalish>, maxBorrowingRate?: Decimalish): Promise<TroveCreationDetails>;
    redeemNECT(amount: Decimalish, maxRedemptionRate?: Decimalish): Promise<RedemptionDetails>;
    registerFrontend(kickbackRate: Decimalish): Promise<void>;
    repayNECT(amount: Decimalish): Promise<TroveAdjustmentDetails>;
    sendNECT(toAddress: string, amount: Decimalish): Promise<void>;
    sendPOLLEN(toAddress: string, amount: Decimalish): Promise<void>;
    // @internal (undocumented)
    setPrice(price: Decimalish): Promise<void>;
    stakePOLLEN(amount: Decimalish): Promise<void>;
    stakeUniTokens(amount: Decimalish): Promise<void>;
    transferCollateralGainToTrove(): Promise<CollateralGainTransferDetails>;
    unstakePOLLEN(amount: Decimalish): Promise<void>;
    unstakeUniTokens(amount: Decimalish): Promise<void>;
    withdrawCollateral(amount: Decimalish): Promise<TroveAdjustmentDetails>;
    withdrawGainsFromStabilityPool(): Promise<StabilityPoolGainsWithdrawalDetails>;
    withdrawGainsFromStaking(): Promise<void>;
    withdrawNECTFromStabilityPool(amount: Decimalish): Promise<StabilityDepositChangeDetails>;
    withdrawPOLLENRewardFromLiquidityMining(): Promise<void>;
}

// @public
export class TransactionFailedError<T extends FailedReceipt = FailedReceipt> extends Error {
    // @internal
    constructor(name: string, message: string, failedReceipt: T);
    // (undocumented)
    readonly failedReceipt: T;
}

// @public
export class Trove {
    // @internal
    constructor(collateral?: Decimal, debt?: Decimal);
    // (undocumented)
    add(that: Trove): Trove;
    // (undocumented)
    addCollateral(collateral: Decimalish): Trove;
    // (undocumented)
    addDebt(debt: Decimalish): Trove;
    adjust(params: TroveAdjustmentParams<Decimalish>, borrowingRate?: Decimalish): Trove;
    adjustTo(that: Trove, borrowingRate?: Decimalish): TroveAdjustmentParams<Decimal>;
    apply(change: TroveChange<Decimal> | undefined, borrowingRate?: Decimalish): Trove;
    readonly collateral: Decimal;
    collateralRatio(price: Decimalish): Decimal;
    collateralRatioIsBelowCritical(price: Decimalish): boolean;
    collateralRatioIsBelowMinimum(price: Decimalish): boolean;
    static create(params: TroveCreationParams<Decimalish>, borrowingRate?: Decimalish): Trove;
    readonly debt: Decimal;
    // (undocumented)
    equals(that: Trove): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    isOpenableInRecoveryMode(price: Decimalish): boolean;
    // (undocumented)
    multiply(multiplier: Decimalish): Trove;
    get netDebt(): Decimal;
    // @internal (undocumented)
    get _nominalCollateralRatio(): Decimal;
    static recreate(that: Trove, borrowingRate?: Decimalish): TroveCreationParams<Decimal>;
    // (undocumented)
    setCollateral(collateral: Decimalish): Trove;
    // (undocumented)
    setDebt(debt: Decimalish): Trove;
    // (undocumented)
    subtract(that: Trove): Trove;
    // (undocumented)
    subtractCollateral(collateral: Decimalish): Trove;
    // (undocumented)
    subtractDebt(debt: Decimalish): Trove;
    // @internal (undocumented)
    toString(): string;
    whatChanged(that: Trove, borrowingRate?: Decimalish): TroveChange<Decimal> | undefined;
}

// @public
export interface TroveAdjustmentDetails {
    fee: Decimal;
    newTrove: Trove;
    params: TroveAdjustmentParams<Decimal>;
}

// Warning: (ae-incompatible-release-tags) The symbol "TroveAdjustmentParams" is marked as @public, but its signature references "_CollateralChange" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveAdjustmentParams" is marked as @public, but its signature references "_NoDebtChange" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveAdjustmentParams" is marked as @public, but its signature references "_DebtChange" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveAdjustmentParams" is marked as @public, but its signature references "_NoCollateralChange" which is marked as @internal
//
// @public
export type TroveAdjustmentParams<T = unknown> = (_CollateralChange<T> & _NoDebtChange) | (_DebtChange<T> & _NoCollateralChange) | (_CollateralChange<T> & _DebtChange<T>);

// @public
export type TroveChange<T> = {
    type: "invalidCreation";
    invalidTrove: Trove;
    error: TroveCreationError;
} | {
    type: "creation";
    params: TroveCreationParams<T>;
} | {
    type: "closure";
    params: TroveClosureParams<T>;
} | {
    type: "adjustment";
    params: TroveAdjustmentParams<T>;
    setToZero?: "collateral" | "debt";
};

// @public
export interface TroveClosureDetails {
    params: TroveClosureParams<Decimal>;
}

// Warning: (ae-incompatible-release-tags) The symbol "TroveClosureParams" is marked as @public, but its signature references "_CollateralWithdrawal" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveClosureParams" is marked as @public, but its signature references "_NoCollateralDeposit" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveClosureParams" is marked as @public, but its signature references "_NECTRepayment" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveClosureParams" is marked as @public, but its signature references "_NoNECTBorrowing" which is marked as @internal
//
// @public
export type TroveClosureParams<T> = _CollateralWithdrawal<T> & _NoCollateralDeposit & Partial<_NECTRepayment<T>> & _NoNECTBorrowing;

// @public
export interface TroveCreationDetails {
    fee: Decimal;
    newTrove: Trove;
    params: TroveCreationParams<Decimal>;
}

// @public
export type TroveCreationError = "missingLiquidationReserve";

// Warning: (ae-incompatible-release-tags) The symbol "TroveCreationParams" is marked as @public, but its signature references "_CollateralDeposit" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveCreationParams" is marked as @public, but its signature references "_NoCollateralWithdrawal" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveCreationParams" is marked as @public, but its signature references "_NECTBorrowing" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TroveCreationParams" is marked as @public, but its signature references "_NoNECTRepayment" which is marked as @internal
//
// @public
export type TroveCreationParams<T = unknown> = _CollateralDeposit<T> & _NoCollateralWithdrawal & _NECTBorrowing<T> & _NoNECTRepayment;

// @public
export interface TroveListingParams {
    readonly beforeRedistribution?: boolean;
    readonly first: number;
    readonly sortedBy: "ascendingCollateralRatio" | "descendingCollateralRatio";
    readonly startingAt?: number;
}

// @public
export class TroveWithPendingRedistribution extends UserTrove {
    // @internal
    constructor(ownerAddress: string, status: UserTroveStatus, collateral?: Decimal, debt?: Decimal, stake?: Decimal, snapshotOfTotalRedistributed?: Trove);
    // (undocumented)
    applyRedistribution(totalRedistributed: Trove): UserTrove;
    // (undocumented)
    equals(that: TroveWithPendingRedistribution): boolean;
    }

// @public
export class UserTrove extends Trove {
    // @internal
    constructor(ownerAddress: string, status: UserTroveStatus, collateral?: Decimal, debt?: Decimal);
    // (undocumented)
    equals(that: UserTrove): boolean;
    readonly ownerAddress: string;
    readonly status: UserTroveStatus;
    // @internal (undocumented)
    toString(): string;
}

// @public
export type UserTroveStatus = "nonExistent" | "open" | "closedByOwner" | "closedByLiquidation" | "closedByRedemption";


// (No @packageDocumentation comment for this package)

```
